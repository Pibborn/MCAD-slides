\documentclass[pdf]{beamer}
\mode<presentation>{\usetheme{Singapore}}
\beamertemplatenavigationsymbolsempty
\title{Leader Election in Arbitrary, Asynchronous Networks}
\author{Michele Castrovilli, Mattia Cerrato, Pasha Ostadi}
\usepackage{default}
\usepackage{graphicx}
\graphicspath{{./img/}}

\begin{document}
\Large
\begin{frame}
    \maketitle
\end{frame}

\normalsize
\begin{frame}{Overview}
    \begin{itemize}
        \item Leader Election: a short review
        \item Floodmax in the asynchronous model
        \item Why use searching/tree building algorithms?
        \item Spanning trees
        \item Breadth-first search
        \item Bellman-Ford algorithm 
    \end{itemize}
\end{frame}

\section{Leader Election}
\begin{frame}{Leader Election}
    The leader is a node in the network that has to `take charge' of a computation
    
    \vspace{12pt}
    \pause
    All nodes have to agree on a single leader
    
    \vspace{12pt}
    \pause
    The criteria for choosing a leader is unimportant; usually the Process ID is used 
    
    \vspace{12pt}
    \pause
    We'll be tackling the leader election problem in an asynchronous arbitrary network 
\end{frame}

\section{Floodmax}
\begin{frame}{Synchronous Floodmax}
    \vspace{12pt}
    Each node knows the diameter \emph{diam} of the network, and has an unique identifier, UID. \\
    \pause
    For every round from 0 to \emph{diam}:  
    \pause
    \begin{enumerate}
        \item Send the maximum ID you found so far
        \pause
        \item Receive another ID, $ID_{2}$. If $ID_{2} >$ UID, \\
         UID $\leftarrow$ $ID_{2}$ 
    \end{enumerate}
    \pause
    After \emph{diam} rounds, every process will have the maximum UID of the network.
    If that UID corresponds to its own, the node will elect itself as the leader.
\end{frame}

\begin{frame}{Asynchronous Floodmax}{FloodMax}
    The FloodMax algorithm can be extended to the asynchronous network, by simulating
    the rounds.\\
    \pause
    \vspace{12pt}
    Each process sends a round r message to the neighbors, each process waits until 
    they received the round r message from every incoming neighbor. \\ 
    At that point, the node can prooced with the next round.\\
    \pause
    \vspace{12pt}
    Simulating \emph{diam} rounds, the algorithm can terminate correctly.
\end{frame}

\begin{frame}{Asynchronous Floodmax}{OptFloodMax}
    An optimization was shown, called \emph{OptFloodMax}.\\
    This optimization reduced greatly the number of messages sent.\\
    \pause
    \vspace{12pt}
    Each node sends to its neighbors an update of the maximum UID they know, only if
    it changed from the previous round.\\
    \pause
    \vspace{12pt}
    This cannot be ported to the asynchronous network, as the nodes cannot determine whether
    they received all the messages from the current round.\\
    \pause
    \vspace{12pt}
    Adding dummy messages to help processes determine the end of the round destroys the 
    optimization.
\end{frame}

\begin{frame}{Asynchronous Floodmax}{OptFloodMax}
    The algorithm can be run purely asynchronously, without rounds.\\
    The processes will propagate UIDs only when they receive a greater one.\\
    \pause
    \vspace{12pt}
    This strategy will eventually propagate the maximum.\\
    \pause
    \vspace{12pt}
    The processes do not know when to terminate.
\end{frame}

\begin{frame}{What can we do?}
    There are different solutions to this problem.\\
    \vspace{12pt}
    We'll be looking at the \emph{Asynchronous broadcast and convergecast, based on breadth-first search}.\\
    \vspace{12pt}
    To solve the leader election problem, we'll start from a spanning tree.
\end{frame}

\section{Spanning Tree}
\begin{frame}{Asynchronous Spanning Tree}{Why?}
    A spanning tree allows for a process to implement broadcast and convergecast on
    an arbitrary network that allows for only point to point communication.\\
    \vspace{12pt}
    By having an unrooted spanning tree, we can also implement a leader election 
    easily.
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{STtoLeader}
    The algorithm uses a convergecast of \emph{elect} messages starting from the leaves.\\
    Each leaf node sends an \emph{elect} message to the unique neighbor.\\
    If a node receives \emph{elect} messages from all its neighbors except one, it 
    then sends an \emph{elect} message to that neighbor.\\
    \vspace{12pt}
    In the end, we have two cases:
    \begin{itemize}
        \item{If a process receives \emph{elect} messages on every channel before
              sending an \emph{elect} message themselves, it elects themselves as a leader.}
        \item{If two \emph{elect} messages are sent on some edge in both directions, then
          one of the two processes at the endpoints will elect itself as a leader, based 
          on some condition (e.g., larger UID).}
    \end{itemize}
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{STtoLeader Results}
    Message complexity: \emph{n}.\\
    Time complexity: $\mathbb{O}(n*(l+d))$.\\
    \vspace{12pt}
    $n$ is the number of nodes in the graph.\\
    $l$ is the upper bound for each task in the process to be completed.
    $d$ is the upper bound for a message to be passed through the channel.
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{Algorithm}
	$AsynchSpanningTree_i$
    \begin{block}{Signature}
        \begin{columns}
            \column{.5\textwidth}
            Input:\\
            \hspace*{\parindent} 
              {$receive("search")_{j,i}, j \in nbrs$}
            \column{.5\textwidth}
            Output:
            \hspace*{\parindent}
            \parbox{\textwidth}{$send("search")_{i,j}, j \in nbrs$\\
               $parent(j)_i, j \in nbrs$}
        \end{columns}
    \end{block}
    \begin{block}{States}
        $parent \in nbrs \cup \{null\}$, initially $null$\\
        $reported$, a Boolean, initially $false$\\
        for every $j \in nbrs$:\\
        \hspace*{\parindent}
        \parbox{\textwidth}{$send(j) \in \{search,null\}$,
        initially $search$ if $i=i_0$, else $null$}
    \end{block}
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{Algorithm}
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{Proof}
	
	
\end{frame}
\begin{frame}{Asynchronous Spanning Tree}{Results}
	
	
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{Broadcast and Child Pointers}
	
	
\end{frame}

\section{Breadth-First Search}
\begin{frame}{Breadth-First Search}{Problem}
	
	
\end{frame}

\begin{frame}{Breadth-First Search}{Algorithm}
	$AsynchBFS_i$
    \begin{block}{Signature}
        \begin{columns}
            \column{.5\textwidth}
            Input:\\
            \hspace*{\parindent} $receive(m)_{i,j}, m \in \mathbb{N}, j \in nbrs$
            \column{.5\textwidth}
            Output:
            \hspace*{\parindent} $send(m)_{i,j}, m \in \mathbb{N}, j \in nbrs$
        \end{columns}
    \end{block}
    \begin{block}{States}
        $dist \in \mathbb{N} \cup \{\infty\}$, initially $0$ if $i=i_0$, $\infty $ otherwise\\
        $parent \in nbrs \cup \{null\}$, initially $null$\\
        for every $j \in nbrs$:\\
        \hspace*{\parindent}
        \parbox{\textwidth}{$send(j)$,
        a FIFO queue of elements of $\mathbb{N}$,
        initially containing the single element $0$ if $i=i_0$, else $\emptyset$}
    \end{block}
	
\end{frame}

\begin{frame}{Breadth-First Search}{Results}
	
	
\end{frame}

\section{BellmanFord}
\begin{frame}{BellmanFord}{Algorithm}
	
	
\end{frame}
\begin{frame}{BellmanFord}{Complexity}
	
	
\end{frame}

\end{document}
