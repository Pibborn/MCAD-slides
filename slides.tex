\documentclass[pdf]{beamer}
\mode<presentation>{\usetheme{Singapore}}
\beamertemplatenavigationsymbolsempty
\title{Leader Election in Arbitrary, Asynchronous Networks}
\author{Michele Castrovilli, Mattia Cerrato, Pasha Ostadi}
\usepackage{default}
\usepackage{graphicx}
\graphicspath{{./img/}}
\usepackage{tcolorbox}

\begin{document}
\Large
\begin{frame}
    \maketitle
\end{frame}

\normalsize
\begin{frame}{Overview}
    \begin{itemize}
        \item Leader Election: a short review
        \item Floodmax in the asynchronous model
        \item Why use searching/tree building algorithms?
        \item Spanning trees
        \item Breadth-first search
        \item Bellman-Ford algorithm 
    \end{itemize}
\end{frame}

\section{Leader Election}
\begin{frame}{Leader Election}
    The leader is a node in the network that has to `take charge' of a computation
    
    \vspace{12pt}
    \pause
    All nodes have to agree on a single leader
    
    \vspace{12pt}
    \pause
    The criteria for choosing a leader is unimportant; usually the Process ID is used 
    
    \vspace{12pt}
    \pause
    We'll be tackling the leader election problem in an asynchronous arbitrary network 
\end{frame}

\section{Floodmax}
\begin{frame}{Synchronous Floodmax}
    \vspace{12pt}
    Each node knows the diameter \emph{diam} of the network, and has an unique identifier, UID. \\
    \pause
    For every round from 0 to \emph{diam}:  
    \pause
    \begin{enumerate}
        \item Send the maximum ID you found so far
        \pause
        \item Receive another ID, $ID_{2}$. If $ID_{2} >$ UID, \\
         UID $\leftarrow$ $ID_{2}$ 
    \end{enumerate}
    \pause
    After \emph{diam} rounds, every process will have the maximum UID of the network.
    If that UID corresponds to its own, the node will elect itself as the leader.
\end{frame}

\begin{frame}{Asynchronous Floodmax}{FloodMax}
    The FloodMax algorithm can be extended to the asynchronous network, by simulating
    the rounds.\\
    \pause
    \vspace{12pt}
    Each process sends a round r message to the neighbors, each process waits until 
    they received the round r message from every incoming neighbor. \\ 
    At that point, the node can prooced with the next round.\\
    \pause
    \vspace{12pt}
    Simulating \emph{diam} rounds, the algorithm can terminate correctly.
\end{frame}

\begin{frame}{Asynchronous Floodmax}{OptFloodMax}
    An optimization was shown, called \emph{OptFloodMax}.\\
    This optimization reduced greatly the number of messages sent.\\
    \pause
    \vspace{12pt}
    Each node sends to its neighbors an update of the maximum UID they know, only if
    it changed from the previous round.\\
    \pause
    \vspace{12pt}
    This cannot be ported to the asynchronous network, as the nodes cannot determine whether
    they received all the messages from the current round.\\
    \pause
    \vspace{12pt}
    Adding dummy messages to help processes determine the end of the round destroys the 
    optimization.
\end{frame}

\begin{frame}{Asynchronous Floodmax}{OptFloodMax}
    The algorithm can be run purely asynchronously, without rounds.\\
    The processes will propagate UIDs only when they receive a greater one.\\
    \pause
    \vspace{12pt}
    This strategy will eventually propagate the maximum.\\
    \pause
    \vspace{12pt}
    The processes do not know when to terminate.
\end{frame}

\begin{frame}{What can we do?}
    There are different solutions to this problem.\\
    \vspace{12pt}
    We'll be looking at the \emph{Asynchronous broadcast and convergecast, based on breadth-first search}.\\
    \vspace{12pt}
    To solve the leader election problem, we'll start from a spanning tree.
\end{frame}

\section{Spanning Tree}
\begin{frame}{Asynchronous Spanning Tree}{Why?}
    A spanning tree allows for a process to implement broadcast and convergecast on
    an arbitrary network that allows for only point to point communication.\\
    \vspace{12pt}
    By having an unrooted spanning tree, we can also implement a leader election 
    easily.
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{STtoLeader}
    The algorithm uses a convergecast of \emph{elect} messages starting from the leaves.\\
    Each leaf node sends an \emph{elect} message to the unique neighbor.\\
    If a node receives \emph{elect} messages from all its neighbors except one, it 
    then sends an \emph{elect} message to that neighbor.\\
    \vspace{12pt}
    In the end, we have two cases:
    \begin{itemize}
        \item{If a process receives \emph{elect} messages on every channel before
              sending an \emph{elect} message themselves, it elects themselves as a leader.}
        \item{If two \emph{elect} messages are sent on some edge in both directions, then
          one of the two processes at the endpoints will elect itself as a leader, based 
          on some condition (e.g., larger UID).}
    \end{itemize}
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{STtoLeader Results}
    Message complexity: \emph{n}.\\
    Time complexity: $\mathbb{O}(n*(l+d))$.\\
    \vspace{12pt}
    $n$ is the number of nodes in the graph.\\
    $l$ is the upper bound for each task in the process to be completed.
    $d$ is the upper bound for a message to be passed through the channel.
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{Algorithm}
	$AsynchSpanningTree_i$
    \begin{block}{Signature}
        \begin{columns}
            \column{.5\textwidth}
            Input:\\
            \hspace*{\parindent} 
              {$receive("search")_{j,i}, j \in nbrs$}
            \column{.5\textwidth}
            Output:
            \hspace*{\parindent}
            \parbox{\textwidth}{$send("search")_{i,j}, j \in nbrs$\\
               $parent(j)_i, j \in nbrs$}
        \end{columns}
    \end{block}
    \begin{block}{States}
        $parent \in nbrs \cup \{null\}$, initially $null$\\
        $reported$, a Boolean, initially $false$\\
        for every $j \in nbrs$:\\
        \hspace*{\parindent}
        \parbox{\textwidth}{$send(j) \in \{search,null\}$,
        initially $search$ if $i=i_0$, else $null$}
    \end{block}
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{Algorithm}
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{Proof}
	
	
\end{frame}
\begin{frame}{Asynchronous Spanning Tree}{Results}
	
	
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{Broadcast and Child Pointers}
	
	
\end{frame}

\section{Breadth-First Search}
\begin{frame}{Breadth-First Search}{Problem}
	Another way to build a Spanning Tree is via Breadth-First Search. \\
    \vspace{12pt}
    \pause
    As in the synchronous setting, we can also find the shortest paths. So we change the graph $G = (V, E)$ to also have \emph{non-negative} weights. A vertex knows about its edges' weights. \\
    \vspace{12pt}
\end{frame}

\section{Breadth-First Search}
\begin{frame}{Breadth-First Search}{Problem}
    To find the shortest paths in a distributed manner, the nodes have to change their parent designations if they are reached along a shorter path. \\
    \vspace{12pt}
    \pause
    However, there is no way to guarantee termination: the node has to wait indefinitely to see if it can obtain a closer parent. \\
    \vspace{12pt}
    \pause
    Even if a Spanning Tree is eventually built, the single nodes cannot be aware of it. \\
    \vspace{12pt}
    \pause
    Some algorithms (LayeredBFS, HybridBFS) solve this problem.
\end{frame}

\begin{frame}{Breadth-First Search}{Algorithm}
	$AsynchBFS_i$
    \begin{block}{Signature}
        \begin{columns}
            \column{.5\textwidth}
            Input:\\
            \hspace*{\parindent} $receive(m)_{i,j}, m \in \mathbb{N}, j \in nbrs$
            \column{.5\textwidth}
            Output:
            \hspace*{\parindent} $send(m)_{i,j}, m \in \mathbb{N}, j \in nbrs$
        \end{columns}
    \end{block}
    \begin{block}{States}
        \begin{tcolorbox}[height=0.8cm,colframe=red]
        $dist \in \mathbb{N} \cup \{\infty\}$, initially $0$ if $i=i_0$, $\infty $ otherwise\\
        \end{tcolorbox}
        $parent \in nbrs \cup \{null\}$, initially $null$\\
        for every $j \in nbrs$:\\
        \hspace*{\parindent}
        \parbox{\textwidth}{$send(j)$,
        a FIFO queue of elements of $\mathbb{N}$,
        initially containing the single element $0$ if $i=i_0$, else $\emptyset$}
    \end{block}
	
\end{frame}

\begin{frame}{Breadth-First Search}{Algorithm}
	\begin{block}{Transitions}
        \vspace{2mm}
        \begin{columns}
            \column{.5\textwidth}
            $\mathbf{send(m)_{i, j}:}$\\ 
                \emph{Precondition}: \\ 
                \small $m$ is first on $send(j)$ \\
                \normalsize \emph{Effect}: \\
                \small remove first element of $send(j)$
            \column{.5\textwidth}
            \normalsize $\mathbf{receive(m)_{i, j}: }$ \\
                \emph{Effect}: \\
                \small
                \begin{tcolorbox}[colframe=red]
                    if $m+1 < dist$ then \\
                    \hspace*{\parindent} $dist := m+1$ \\
                    \hspace*{\parindent} $parent = j$ \\
                    \hspace*{\parindent} for all $k \in nbrs - \{j\}$ do \\
                    \hspace*{\parindent} \hspace*{\parindent} add $dist$ to $send(k)$ \\
                \end{tcolorbox}
        \end{columns}
	\end{block}
\end{frame}

\begin{frame}{Breadth-First Search}{Results}
    \begin{columns}
        \column{.5\textwidth}
            Message Complexity: \\
            \hspace*{\parindent} $\mathbb{O}(n|E|)$ \\
            \pause
            \small
            Because each node can acquire different up to $n$ estimates of its distance to the starting node. In the worst case scenario, each estimate causes an update, each requiring at most $|E|$ messages to notify the adjacent nodes.
        \pause
        \column{.5\textwidth}
            \normalsize
            Time Complexity:
            \hspace*{\parindent} $\mathbb{O}(diam \times n(l + d))$ \\
            \pause
            \small
            Because the length of a shortest path from the starting node to any node is at most $diam$; and at most $n$ messages are ever in any channel. \\
           
    \end{columns} 
\end{frame}

\section{BellmanFord}
\begin{frame}{BellmanFord}{Algorithm}
	
	
\end{frame}
\begin{frame}{BellmanFord}{Complexity}
	
	
\end{frame}

\end{document}
