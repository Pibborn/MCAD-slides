\documentclass[pdf]{beamer}
\mode<presentation>{\usetheme{Singapore}}
\beamertemplatenavigationsymbolsempty
\title{Leader Election in Arbitrary, Asynchronous Networks}
\author{Michele Castrovilli, Mattia Cerrato, Pasha Ostadi}
\usepackage{default}
\usepackage{graphicx}
\graphicspath{ {./img/} }

\begin{document}
\Large
\begin{frame}
    \maketitle
\end{frame}

\normalsize
\begin{frame}{Overview}
    \begin{itemize}
        \item Leader Election: a short review
        \item Floodmax in the asynchronous model
        \item Why use searching/tree building algorithms?
        \item Spanning trees
        \item Breadth-first search
        \item Bellman-Ford algorithm 
    \end{itemize}
\end{frame}

\section{Leader Election}
\begin{frame}{Leader Election}
    The leaders is a node in the network that has to "take charge" of a computation
    
    \vspace{12pt}
    \pause
    All nodes have to agree on a single leader
    
    \vspace{12pt}
    \pause
    The criteria for choosing a leader is unimportant; usually the Process ID is used 
\end{frame}

\section{Floodmax}
\begin{frame}{Synchronous Floodmax}
    \vspace{12pt}
    Each node knows the diameter \emph{diam} of the network, and has an unique identifier, UID. \\
    \pause
    For every round from 0 to \emph{diam}:  
    \pause
    \begin{enumerate}
        \item Send the maximum ID you found so far
        \pause
        \item Receive another ID, $ID_{2}$. If $ID_{2} >$ UID, \\
         UID $\leftarrow$ $ID_{2}$ 
    \end{enumerate}
\end{frame}

\begin{frame}{Asynchronous Floodmax}
    
\end{frame}

\section{Spanning Tree}
\begin{frame}{Asynchronous Spanning Tree}{Why?}
	
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{Algorithm}

\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{Proof}
	
	
\end{frame}
\begin{frame}{Asynchronous Spanning Tree}{Results}
	
	
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{Broadcast and Child Pointers}
	
	
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{STtoLeader}
	
	
\end{frame}

\section{Breadth-First Search}
\begin{frame}{Breadth-First Search}{Problem}
	
	
\end{frame}

\begin{frame}{Breadth-First Search}{Algorithm}
	
	
\end{frame}

\begin{frame}{Breadth-First Search}{Results}
	
	
\end{frame}

\section{BellmanFord}
\begin{frame}{BellmanFord}{Algorithm}
	$AsynchBFS_i$
	\begin{block}{Signature}
		\begin{columns}
			\column{.5\textwidth}
			Input:\\
			\hspace*{\parindent} $receive(m)_{i,j}, m \in \mathbb{N}, j \in nbrs$
			\column{.5\textwidth}
			Output:
			\hspace*{\parindent} $send(m)_{i,j}, m \in \mathbb{N}, j \in nbrs$
		\end{columns}
	\end{block}
	\begin{block}{States}
	$dist \in \mathbb{N} \cup \{\infty\}$, initially $0$ if $i=i_0$, $\infty $ otherwise\\
	$parent \in nbrs \cup \{null\}$, initially $null$\\
	for every $j \in nbrs$:\\
	\hspace*{\parindent}
	\parbox{\textwidth}{
	$send(j)$, a FIFO queue of elements of $\mathbb{N}$, initially containing the single element $0$ if $i=i_0$, else $\emptyset$}
	\end{block}
	
\end{frame}
\begin{frame}{BellmanFord}{Complexity}
	
	
\end{frame}

\end{document}