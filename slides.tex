\documentclass[pdf]{beamer}
\mode<presentation>{\usetheme{Singapore}}
\beamertemplatenavigationsymbolsempty
\title{Leader Election in Arbitrary, Asynchronous Networks}
\author{Michele Castrovilli, Mattia Cerrato, Pasha Ostadi}
\usepackage{default}
\usepackage{graphicx}
\graphicspath{{./img/}}
\usepackage[absolute,overlay]{textpos}

\begin{document}
\Large
\begin{frame}
    \maketitle
\end{frame}

\normalsize
\begin{frame}{Overview}
    \begin{itemize}
        \item Leader Election: a short review
        \item Floodmax in the asynchronous model
        \item Why use searching/tree building algorithms?
        \item Spanning trees
        \item Breadth-first search
        \item Bellman-Ford algorithm 
    \end{itemize}
\end{frame}

\section{Leader Election}
\begin{frame}{Leader Election}
    The leader is a node in the network that has to `take charge' of a computation
    
    \vspace{12pt}
    \pause
    All nodes have to agree on a single leader
    
    \vspace{12pt}
    \pause
    The criteria for choosing a leader is unimportant; usually the Process ID is used 
    
    \vspace{12pt}
    \pause
    We'll be tackling the leader election problem in an asynchronous arbitrary network 
\end{frame}

\section{Floodmax}
\begin{frame}{Synchronous Floodmax}
    \vspace{12pt}
    Each node knows the diameter \emph{diam} of the network, and has an unique identifier, UID. \\
    \pause
    For every round from 0 to \emph{diam}:  
    \pause
    \begin{enumerate}
        \item Send the maximum ID you found so far
        \pause
        \item Receive another ID, $ID_{2}$. If $ID_{2} >$ UID, \\
         UID $\leftarrow$ $ID_{2}$ 
    \end{enumerate}
    \pause
    After \emph{diam} rounds, every process will have the maximum UID of the network.
    If that UID corresponds to its own, the node will elect itself as the leader.
\end{frame}

\begin{frame}{Asynchronous Floodmax}{FloodMax}
    The FloodMax algorithm can be extended to the asynchronous network, by simulating
    the rounds.\\
    \pause
    \vspace{12pt}
    Each process sends a round r message to the neighbors, each process waits until 
    they received the round r message from every incoming neighbor. \\ 
    At that point, the node can prooced with the next round.\\
    \pause
    \vspace{12pt}
    Simulating \emph{diam} rounds, the algorithm can terminate correctly.
\end{frame}

\begin{frame}{Asynchronous Floodmax}{OptFloodMax}
    An optimization for the synchronous case was shown, called \emph{OptFloodMax}.\\
    This optimization reduced greatly the number of messages sent.\\
    \pause
    \vspace{12pt}
    Each node sends to its neighbors an update of the maximum UID they know, only if
    it changed from the previous round.\\
    \pause
    \vspace{12pt}
    This cannot be ported to the asynchronous network, as the nodes cannot determine whether
    they received all the messages from the current round.\\
    \pause
    \vspace{12pt}
    Adding dummy messages to help processes determine the end of the round destroys the 
    optimization.
\end{frame}

\begin{frame}{Asynchronous Floodmax}{OptFloodMax}
    The algorithm can be run purely asynchronously, without rounds.\\
    The processes will propagate UIDs only when they receive a greater one.\\
    \pause
    \vspace{12pt}
    This strategy will eventually propagate the maximum.\\
    \pause
    \vspace{12pt}
    The processes do not know when to terminate.
\end{frame}

\begin{frame}{What can we do?}
    There are different solutions to this problem.\\
    \vspace{12pt}
    We'll be looking at the \emph{Asynchronous broadcast and convergecast, based on breadth-first search}.\\
    \vspace{12pt}
    To solve the leader election problem, we'll start from a spanning tree.
\end{frame}

\section{Spanning Tree}
\begin{frame}{Asynchronous Spanning Tree}{Why?}
    A spanning tree allows for a process to implement broadcast and convergecast on
    an arbitrary network that allows for only point to point communication.\\
    \vspace{12pt}
    By having an unrooted spanning tree, we can also implement a leader election 
    easily.
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{STtoLeader}
    The algorithm uses a convergecast of \emph{elect} messages starting from the leaves.\\
    Each leaf node sends an \emph{elect} message to the unique neighbor.\\
    If a node receives \emph{elect} messages from all its neighbors except one, it 
    then sends an \emph{elect} message to that neighbor.\\
    \vspace{12pt}
    In the end, we have two cases:
    \begin{itemize}
        \item{If a process receives \emph{elect} messages on every channel before
              sending an \emph{elect} message themselves, it elects themselves as a leader.}
        \item{If two \emph{elect} messages are sent on some edge in both directions, then
          one of the two processes at the endpoints will elect itself as a leader, based 
          on some condition (e.g., larger UID).}
    \end{itemize}
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{STtoLeader Results}
    Message complexity: \emph{n}.\\
    Time complexity: $\mathcal{O}(n*(l+d))$.\\
    \vspace{12pt}
    $n$ is the number of nodes in the graph.\\
    $l$ is the upper bound for each task in the process to be completed.
    $d$ is the upper bound for a message to be passed through the channel.
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{Algorithm}
	$AsynchSpanningTree_i$
    \begin{block}{Signature}
        \begin{columns}
            \column{.5\textwidth}
            Input:\\
            \hspace*{2pt} 
              {$receive("search")_{j,i}, j \in nbrs$}
            \column{.5\textwidth}
            Output:
            \hspace*{2pt}
            \parbox{\textwidth}{$send("search")_{i,j}, j \in nbrs$\\
               $parent(j)_i, j \in nbrs$}
        \end{columns}
    \end{block}
    \begin{block}{States}
        $parent \in nbrs \cup \{null\}$, initially $null$\\
        $reported$, a Boolean, initially $false$\\
        for every $j \in nbrs$:\\
        \hspace*{2pt}
        \parbox{\textwidth}{$send(j) \in \{search,null\}$,
        initially $search$ if $i=i_0$, else $null$}
    \end{block}
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{Algorithm}
    \begin{block}{Transitions}
        \begin{columns}[t]
            \column{.5\textwidth}
            $send("search")_{i,j}$ \\
            \hspace*{2pt} {Precondition:} \\
            \hspace*{5pt} {$send(j) = search$} \\
            \hspace*{2pt} {Effect:} \\
            \hspace*{5pt} {$send(j) := search$} \\
            \vspace{12pt}
            $receive("search")_{j,i}$ \\
            \hspace*{2pt} {Effect:} \\
            \hspace*{5pt} {if $i \neq i_0$ and $parent = null$ then}\\
            \hspace*{7pt} {$parent := j$} \\
            \hspace*{7pt} {for all $k \in nbrs - \{j\}$ do} \\
            \hspace*{9pt} {$send(k) := search$} 
            \column{.5\textwidth}
            $parent(j)_{i}$ \\
            \hspace*{2pt} {Precondition:} \\
            \hspace*{5pt} {$parent = j$} \\
            \hspace*{5pt} {$reported = false$} \\
            \hspace*{2pt} {Effect:} \\
            \hspace*{5pt} {$reported := true$} 
        \end{columns}
    \end{block}
    \vskip-3cm
    \begin{columns}
     \column{.5\textwidth}
    \column{.5\textwidth}
    \begin{block}{Tasks}
    $\{parent(j)_i : j \in nbrs\}$\\
    for every $j \in nbrs$: \\
        \hspace*{2pt}
        \parbox{\textwidth}{$\{send("search")_{i,j}\}$}
    \end{block}
    \end{columns}
\end{frame}

\begin{frame}[plain]{Asynchronous Spanning Tree}{Proof}
    \begin{block}{Assertion 1}
    In any reachable state, the edges defined by all the parent variables form a spanning tree
    of a subgraph of $G$, containing $i_0$; moreover, if there is a message in any channel $C_{i,j}$,
    then $i$ is in this spanning tree.
    \end{block}	
    \pause
    \begin{block}{Proof - Base case (will be reduced, along with blackboard explaining)}
    The first part is trivially proven,
    as there are no parent variables, and $G$ contains $i_0$ by definition.\\
    Second part, we have search messages starting only from $i_0$, by the algorithm definition.\\
    \end{block}
\end{frame}

\begin{frame}[plain]{Asynchronous Spanning Tree}{Proof}
    \begin{block}{Assertion 1}
    In any reachable state, the edges defined by all the parent variables form a spanning tree
    of a subgraph of $G$, containing $i_0$; moreover, if there is a message in any channel $C_{i,j}$,
    then $i$ is in this spanning tree.
    \end{block}	
    \begin{block}{Proof - Inductive step (will be reduced, along with blackboard explaining)}
    We look at each transition, and how it does not change the invariant.
    \begin{description}
    \item[$send$]{Since the send transition sends a message from the node i to the neighbors, we need
        to prove that i is in the spanning tree. By the algorithm, the send transition has the precondition of the $send(j)$ variable, which is set only as the node enters the spanning tree.}
    \end{description}
    \end{block}
\end{frame}

\begin{frame}[plain]{Asynchronous Spanning Tree}{Proof}
    \begin{block}{Assertion 1}
    In any reachable state, the edges defined by all the parent variables form a spanning tree
    of a subgraph of $G$, containing $i_0$; moreover, if there is a message in any channel $C_{i,j}$,
    then $i$ is in this spanning tree.
    \end{block}	
    \begin{block}{Proof - Inductive step (will be reduced, along with blackboard explaining)}
    \begin{description}
    \item[$receive$]{\small The receive of a search message to a node not in the spanning tree, allows for the node to enter the spanning tree by setting the parent variable to the neighbor that sent the message. It then sets the variables in order to send the search message to the remaining neighbors.\\
        If the node already has the parent variable set, it discards the message. 
    Since this only adds a node, $i_0$ is still contained in the spanning tree.}
    \end{description}
    \end{block}
\end{frame}

\begin{frame}[plain]{Asynchronous Spanning Tree}{Proof}
    \begin{block}{Assertion 1}
    In any reachable state, the edges defined by all the parent variables form a spanning tree
    of a subgraph of $G$, containing $i_0$; moreover, if there is a message in any channel $C_{i,j}$,
    then $i$ is in this spanning tree.
    \end{block}	
    \begin{block}{Proof - Inductive step (will be reduced, along with blackboard explaining)}
    \begin{description}
    \item[$parent$]{The parent action will activate once, as the parent variable is set, reporting the node's presence in the spanning tree.}
    \end{description}
    \end{block}
\end{frame}

\begin{frame}[plain]{Asynchronous Spanning Tree}{Proof}
    \begin{block}{Assertion 2 - Liveness}
        In any reachable state, if $i=i_0$ or $parent_i \neq null$, and if $j \in nbrs_i - \{i_0\}$,
        then either $parent_j \neq null$ or $C_{i,j}$ contains a $search$ message or $send(j)_i$ contains a $search$ message.
    \end{block}	
    \begin{block}{Proof - Base step (will be reduced, along with blackboard explaining)}
    As the initial state, we have that every $parent_i = null$, so we need to only check $i_0$.
    As the initial state, $i_0$ has that for all its neighbors $send(j)_i$ contains a search message,
    therefore proving the invariant.
    \end{block}
\end{frame}
\begin{frame}[plain]{Asynchronous Spanning Tree}{Proof}
    \begin{block}{Assertion 2 - Liveness}
        In any reachable state, if $i=i_0$ or $parent_i \neq null$, and if $j \in nbrs_i - \{i_0\}$,
        then either $parent_j \neq null$ or $C_{i,j}$ contains a $search$ message or $send(j)_i$ contains a $search$ message.
    \end{block}	
    \begin{block}{Proof - Inductive step (will be reduced, along with blackboard explaining)}
    We look at each transition, and show how it doesn't invalidate the invariant.
    \begin{description}
    \item[$send$]{As the effect will remove the $search$ message from the $send(j)$ variable, the channel $C_{i,j}$ will now contain a $search$ message instead.}
    \end{description}
    \end{block}
\end{frame}
\begin{frame}[plain]{Asynchronous Spanning Tree}{Proof}
    \begin{block}{Assertion 2 - Liveness}
        In any reachable state, if $i=i_0$ or $parent_i \neq null$, and if $j \in nbrs_i - \{i_0\}$,
        then either $parent_j \neq null$ or $C_{i,j}$ contains a $search$ message or $send(j)_i$ contains a $search$ message.
    \end{block}	
    \begin{block}{Proof - Inductive step (will be reduced, along with blackboard explaining)}
    \begin{description}
    \item[$receive$]{As $parent_i$ becomes different than $null$, for each $j \in nbrs - {parent_i}$,
    it will set $send(j) = search$. For $parent_i$ instead, we can already prove from the first assertion that since a message came from $parent_i$ it must be in the spanning tree, and so its $parent$ variable different than $null$.}
    \item[$parent$]{It doesn't affect any of the variables in the assertion.}
    \end{description}
    \end{block}
\end{frame}
\begin{frame}[plain]{Asynchronous Spanning Tree}{Proof}
    \begin{block}{Assertion 1}
    In any reachable state, the edges defined by all the parent variables form a spanning tree
    of a subgraph of $G$, containing $i_0$; moreover, if there is a message in any channel $C_{i,j}$,
    then $i$ is in this spanning tree.
    \end{block}	
    \begin{block}{Assertion 2 - Liveness}
        In any reachable state, if $i=i_0$ or $parent_i \neq null$, and if $j \in nbrs_i - \{i_0\}$,
        then either $parent_j \neq null$ or $C_{i,j}$ contains a $search$ message or $send(j)_i$ contains a $search$ message.
    \end{block}	
    \begin{block}{Conclusions}
        From these two assertions we can then argue that the algorithm constructs a spanning tree.\\
        Furthermore, for any $i \neq i_0$ we have $parent_i \neq null$ within time $distance(i_0,i)\cdot(l+d)$, which implies the liveness.
    \end{block}
\end{frame}
\begin{frame}{Asynchronous Spanning Tree}{Results}
    Number of messages: $\mathcal{O}(|E|)$.\\
    Time upper bound for all processes except $i_0$: $diam(l+d)+l$.\\
    \vspace{6pt}
    $|E|$ is the number of edges in the graph.\\
    $n$ is the number of nodes in the graph.\\
    $l$ is the upper bound for each task in the process to be completed.\\
    $d$ is the upper bound for a message to be passed through the channel.\\
    \pause
    \vspace{6pt}
    The paths might be longer than the diameter, nonetheless the time is still bounded in 
    terms of diameter, because the time of the shortest path might be greater than the 
    fastest one.
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{Broadcast and Child Pointers}
    \begin{block}{Broadcast}
        It's easy to modify the algorithm, as we use a method of \emph{piggybacking} on the
        $search$ message. It also shares the complexities as the spanning tree algorithm.
    \end{block}
    \begin{block}{Child Pointers}
        Since the graph is assumed to be undirected, it's easy for the children to reply
        directly to the parent, in order for the parent to acknowledge them, or not.\\
        This can also implement \emph{broadcasting}.\\
        The complexity of the approach is $\mathcal{O}(n)$ per broadcast, and time complexity
        $\mathcal{O}(h(l+d))$ where $h$ is the height of the spanning tree, which is might be bounded
        as $\mathcal{O}(n(l+d))$ if a \emph{AsynchSpanningTree} was used, as the height might be bigger than the diameter. \\
    \end{block}
\end{frame}

\begin{frame}{Asynchronous Spanning Tree}{Broadcast and Child Pointers}
    \begin{block}{Child Pointers}
        The spanning tree with child pointers can also be used for \emph{convergecast}, with the same complexities as the broadcast.\\
        The two can be combined in a broadcast, followed by a convergecast to acknowledge the receival.
    \end{block}
    \begin{block}{Leader Election}
        By allowing every node to initiate a broadcast-convergecast, and having UIDs, we can also solve the leader election problem, with every node discovering the maximum UID in the network, and then electing itself as a leader if the maximum UID equals to its own.\\
        The message complexity of this approach is $\mathcal{O}(n|E|)$.
    \end{block}
\end{frame}

\section{Breadth-First Search}
\begin{frame}{Breadth-First Search}{Problem}
	
	
\end{frame}

\begin{frame}{Breadth-First Search}{Algorithm}
	$AsynchBFS_i$
    \begin{block}{Signature}
        \begin{columns}
            \column{.5\textwidth}
            Input:\\
            \hspace*{\parindent} $receive(m)_{i,j}, m \in \mathbb{N}, j \in nbrs$
            \column{.5\textwidth}
            Output:
            \hspace*{\parindent} $send(m)_{i,j}, m \in \mathbb{N}, j \in nbrs$
        \end{columns}
    \end{block}
    \begin{block}{States}
        $dist \in \mathbb{N} \cup \{\infty\}$, initially $0$ if $i=i_0$, $\infty $ otherwise\\
        $parent \in nbrs \cup \{null\}$, initially $null$\\
        for every $j \in nbrs$:\\
        \hspace*{\parindent}
        \parbox{\textwidth}{$send(j)$,
        a FIFO queue of elements of $\mathbb{N}$,
        initially containing the single element $0$ if $i=i_0$, else $\emptyset$}
    \end{block}
	
\end{frame}

\begin{frame}{Breadth-First Search}{Results}
	
	
\end{frame}

\section{BellmanFord}
\begin{frame}{BellmanFord}{Algorithm}
	
	
\end{frame}
\begin{frame}{BellmanFord}{Complexity}
	
	
\end{frame}

\end{document}
